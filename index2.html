<!DOCTYPE html>
<meta charset="utf-8">

<head>
	<style>
		.background {
		  	fill: #fff;
		}
		rect {
  			stroke: #fff;
  			stroke-width: 1;
		}
		text {
  			text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
  			cursor: move;
		}
	</style>
	<title> MATRIX DRAG AND DROP </title>
</head>

<body>
	
<script src="https://d3js.org/d3.v7.min.js"></script>

<script>

	var n = 6;

	var margin = {top: 50, right: 30, bottom: 30, left: 50},
		width = 800 - margin.left - margin.right,
		height = 800 - margin.top - margin.bottom;

	var matrixA = [],
		matrixB = [],
	  	nodes = [{"name": "A"},
	  			{"name": "B"}, 
	  			{"name": "C"}, 
	  			{"name": "D"}, 
	  			{"name": "E"}, 
	  			{"name":"F"} ],
	  	n = nodes.length;

	// Default order
  	var orders = {
		name: d3.range(n).sort(function(a, b) { return d3.ascending(nodes[a].name, nodes[b].name); })
  	};

	var y = d3.scaleBand()
			.domain(orders.name)
			.range([0, height])
			.paddingInner(0) // edit the inner padding value in [0,1]
    		.paddingOuter(1),
		x = d3.scaleBand()
			.domain(orders.name)
			.range([0, width])
			.paddingInner(0) // edit the inner padding value in [0,1]
    		.paddingOuter(1),
		c = d3.scaleOrdinal(d3.schemeCategory10);

	var dragging = {};

	var svg = d3.select("body")
		.append("svg")
		.attr("width", width + margin.left + margin.right)
		.attr("height", height + margin.top + margin.bottom)
		.style("margin-left", margin.left + "px")
		.append("g")
		.attr("id", "matrix")
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	nodes.forEach(function(node, i) {
		node.index = i;
		node.count = 0;
		matrixA[i] = d3.range(n).map(function(j) { 
			return {x: j, y: i, z: 1 + (n * i) + j}; });
		matrixB[i] = d3.range(n).map(function(j) { 
			return {x: i, y: j, z: (n * j) + 1 + i}; });
  	});

  	svg.append("rect")
	  .attr("class", "background")
	  .attr("width", width)
	  .attr("height", height);

	var column = svg.selectAll(".column")
		.data(matrixB)
		.join(
			enter => enter
				.append("g")
				.attr("class", "column")
				.attr("transform", (d, i) => "translate(" + x(i) + ")rotate(-90)" )
				.each(column),
			update => update,
			exit => exit.remove()
		)
		// .enter()
		// .append("g")
		// .attr("class", "column")
		// .attr("transform", (d, i) => "translate(" + x(i) + ")rotate(-90)" )
		// .each(column)
		

	var drag_behavior = d3.drag();
	var trigger;

	column.append("text")
  		.attr("class", "label")
		.attr("x", -60)
		.attr("y", x.bandwidth() / 2)
		.attr("dy", ".32em")
		.attr("text-anchor", "start")
		.text(function(d, i) { return nodes[i].name; });


	let drag = d3.drag()
			.subject(function(event, d) {
				return {x: x(d[0].x)}; 
			})
			.on("start", function(event, d) {
				trigger = event.sourceEvent.target.className.baseVal;

				if (trigger == "label") {
					dragging[d[0].x] = x(d[0].x);

					// Move the column that is moving on the front
					sel = d3.select(this);
					sel.moveToFront();
				}
			})
			.on("drag", function(event, d) {
				// Hide what is in the back
				// console.log(d3.event.x);
				// console.log(d3.event.y);
				if (trigger == "label") {
	   				// d3.selectAll(".cellrow").attr("opacity", 0);

				  	dragging[d[0].x] = Math.min(width, Math.max(0, event.x));
				  	orders.name.sort(function(a, b) { return cPosition(a) - cPosition(b); });
				  	x.domain(orders.name);

				  	// console.log(orders.name);

				  	d3.selectAll(".column").attr("transform", function(d, i) { 
						return "translate(" + cPosition(d[0].x) + ")rotate(-90)"; 
					});
				}
		  

			})
			.on("end", function(event, d) {
			  	delete dragging[d[0].x];
			  	transition(d3.select(this)).attr("transform", "translate(" + x(d[0].x) + ")rotate(-90)");
			  	d3.selectAll(".row").each(function(d, i) {
				d3.select(this).selectAll(".cellrow").attr("x", function(d) { 
					return x(d[0].x); });
			  	});

			});

	d3.selectAll(".column").call(drag);
		
	function row(row) {
		var cell = d3.select(this).selectAll(".cellrow")
			.data(row.filter(function(d) { 
				return d.z; 
			}))
			.enter()
			.append("rect")
			.attr("class", "cellrow")
			.attr("x", function(d) {
				return y(d.x); 
			})
			.attr("width", y.bandwidth())
			.attr("height", y.bandwidth())
			.style("fill", function(d) { 
				return c(d.z); 
			});
  	}

  	function column(column) {
		var cell = d3.select(this).selectAll(".cellcolumn")
			.data(column.filter(function(d) { 
				return d.z; 
			}))
			.enter().append("rect")
			.attr("class", "cellcolumn")
			.attr("x", function(d) { 
				return -x(d.y)-90; 
			})
			.attr("width", x.bandwidth())
			.attr("height", x.bandwidth())
			.style("fill", function(d) { 
				return c(d.z); 
			});

  	}

  	d3.selection.prototype.moveToFront = function() {
	  	return this.each(function(){
			this.parentNode.appendChild(this);
	  	});
	};

	function position(d) {
	  	var v = dragging[d];
	  	return v == null ? y(d) : v;
	}

	function cPosition(d) {
	  	var v = dragging[d];
	  	return v == null ? x(d) : v;
	}

	function transition(g) {
	  	return g.transition().duration(500);
	}



</script>

</body>